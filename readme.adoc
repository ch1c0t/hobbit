[[installation]]
== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem 'hobby'
# or this if you want to use hobby master
# gem 'hobby', github: 'ch1c0t/hobby'
----

And then execute:

[source,bash]
----
$ bundle
----

Or install it yourself as:

[source,bash]
----
$ gem install hobby
----

[[introduction]]
== Introduction

Hobby features a Sinatra-like DSL, but in contrast to Sinatra,
Hobby applications behave like usual Ruby classes.

To create a Hobby application, you create a class and include `Hobby` in it.
For example:

[source,ruby]
----
class C
  include Hobby

  get("/hello") {
    "Hello, world."
  }
end
----

Then, you can create an instance of `C` with

[source,ruby]
----
C.new
----

which will return a Rack application(an object which complies to 
http://rubydoc.info/github/rack/rack/master/file/SPEC[Rack SPEC]).

You can set some state in `#initialize` and then use it in the route's action:

[source,ruby]
----
class C
  include Hobby

  def initialize name
    @name = name
  end

  get("/hello") {
    "Hello, #{@name}."
  }
end
----

To run an application, you can put it into `config.ru`:

[source,ruby]
----
run C.new 'Hobby'
----

and then use `rackup`:

[source,bash]
----
$ rackup
----

Or, if you are using Rails, you can mount it in `config/routes.rb` with:
[source,ruby]
----
mount C.new('Hobby') => '/some_path'
----

[[features]]
Features
~~~~~~~~

* DSL inspired by http://www.sinatrarb.com/[Sinatra].
* https://github.com/luislavena/bench-micro[Speed].
* Extensible with standard ruby classes and modules, with no extra
logic. See https://github.com/ch1c0t/hobby-auth[hobby-auth] and
https://github.com/ch1c0t/hobby-json[hobby-json].
* Zero configuration.

[[routes]]
== Routes

For common HTTP verbs, Hobby provides the route definers(methods named accordingly):

[source,ruby]
----
class App
  include Hobby

  get '/' do
    # ...
  end

  post '/' do
    # ...
  end

  put '/' do
    # ...
  end

  patch '/' do
    # ...
  end

  delete '/' do
    # ...
  end

  options '/' do
    # ...
  end
end
----

A definer should be called with a path(optional) and an action(passed as a block).

Calling a definer has a side effect of defining a route in the router.
When an incoming request matches a route,
the action is executed and a response is sent back to the client.
The return value of the action will be the `body` of the response.

If a path was omitted
[source,ruby]
----
get do
  'The body returned to the HTTP client making the request.'
end
----

the action is attached to the root route, like if
[source,ruby]
----
get '/' do
  'The body returned to the HTTP client making the request.'
end
----

were called.


[[default-helpers]]
== Default helpers

The following methods are predefined:

* `env`: a `Hash`, http://www.rubydoc.info/github/rack/rack/master/file/SPEC#The_Environment[a Rack environment].
* `request`: a http://www.rubydoc.info/gems/rack/Rack/Request[`Rack::Request`].
* `response`: a http://www.rubydoc.info/gems/rack/Rack/Response[`Rack::Response`].
* `my`: a `Hash` which stores route variables. See <<routes-with-variables>> for a usage example.

[[routes-with-variables]]
=== Routes with variables

[source,ruby]
----
require 'hobby'

class App
  include Hobby
  # matches both /hi/hobbit and /hi/patricio
  get '/hi/:name' do
    "Hello #{my[:name]}"
  end
end
----

[[halting]]
Halting
+++++++

To immediately stop a request within route you can use `throw :halt`.

[source,ruby]
----
require 'hobby'

class App < Hobbit::Base
  use Rack::Session::Cookie, secret: SecureRandom.hex(64)

  def session
    env['rack.session']
  end

  get '/' do
    response.status = 401
    throw :halt, response.finish
  end
end
----

[[mapping-applications]]
Mapping applications
++++++++++++++++++++

You can mount any Rack application to the stack by using the `map` class
method:

[source,ruby]
----
require 'hobby'

class InnerApp
  include Hobby

  # gets called when path_info = '/inner'
  get do
    'Hello InnerApp!'
  end
end

class App
  include Hobby

  map('/inner') { run InnerApp.new }

  get '/' do
    'Hello App!'
  end
end
----

[[using-middleware]]
Using middleware
++++++++++++++++

You can add any Rack middleware to the stack by using the `use` class
method:

[source,ruby]
----
require 'hobby'

class App
  include Hobby

  use Rack::Session::Cookie, secret: SecureRandom.hex(64)
  use Rack::ShowExceptions

  def session
    env['rack.session']
  end

  get '/' do
    session[:name] = 'hobbit'
  end

  # more routes...
end

run App.new
----

[[extensions]]
Extensions
^^^^^^^^^^

You can extend Hobbit by creating standard ruby modules. See an example:

[source,ruby]
----
module MyExtension
  def do_something
    # do something
  end
end

class App
  include Hobby
  include MyExtension

  get '/' do
    do_something
    'Hello World!'
  end
end
----

[[available-extensions]]
Available extensions
++++++++++++++++++++

* https://github.com/ch1c0t/hobby-auth[hobby-auth]: User authorization.
* https://github.com/ch1c0t/hobby-json[hobby-json]: JSON requests and
responses.
